{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE ScopedTypeVariables        #-}


module Components.Grid
  ( gridComponent
  , GridCommand(..)
  , GridAction(..)
  , GridOptions(..)
  , defaultGridOptions
  ) where

import           Prelude                        hiding (div)
import qualified Prelude

import           Control.Applicative
import qualified Data.Set as Set
import           Data.Maybe
import           Data.Monoid

import qualified Web.VirtualDom.Html            as E
import qualified Web.VirtualDom.Html.Attributes as A
import qualified Web.VirtualDom.Html.Events     as Ev

import           Lubeck.App                     (Html)
import           Lubeck.Forms
import           Lubeck.FRP
import qualified Lubeck.FRP                     as FRP
import           Lubeck.Util

-- import           BD.Types
import           BDPlatform.HTMLCombinators


data GridAction a = Select [a] | Delete [a] | Other [a] | SelectNone | Noop deriving Show
data GridCommand a = Replace [a] | ClearSelection

data GridOptions = GridOptions { deleteButton     :: Bool
                               , selectButton     :: Bool
                               , otherButton      :: Bool
                               , initialSelection :: Set.Set a 
                               , width            :: Int -- px
                               , height           :: Int }

defaultGridOptions = GridOptions True True True Set.empty 200 200

gridW :: Ord a => GridOptions -> (a -> Html) -> Widget ([a], Set.Set a) (GridAction a)
gridW _    _     _        ([], _)              = contentPanel mempty
gridW opts itemW gridSink (items, selectedSet) = contentPanel $ E.div []
  [ E.div [A.class_ "grid-container"] (map (itemWrapperW opts itemW selectedSet gridSink) items) ]

itemWrapperW :: Ord a => GridOptions -> (a -> Html) -> Set.Set a -> Widget a (GridAction a)
itemWrapperW opts itemW selectedSet gridSink x =
  let selIcon = if Set.member x selectedSet then "check-square" else "check-square-o"
      selCls  = if Set.member x selectedSet then "grid-cell-selected" else ""

  in E.div [ A.class_ ("grid-item-wrapper " <> selCls), A.style $ "width: " <> showJS (width opts) <> "px; height: " <> showJS (height opts) <> "px;"]
        ([buttonIcon_ "btn-link grid-item-delete" "" "trash"    False [Ev.click $ \_ -> gridSink $ Delete [x]] | deleteButton opts]
      <> [buttonIcon_ "btn-link grid-item-select" "" selIcon    False [Ev.click $ \_ -> gridSink $ Select [x]] | selectButton opts]
      <> [buttonIcon_ "btn-link grid-item-other"  "" "circle-o" False [Ev.click $ \_ -> gridSink $ Other  [x]] | otherButton opts]
      <> [itemW x])

gridComponent :: Ord a => Maybe GridOptions               -- custom grid options
                       -> [a]                             -- initial items
                       -> Widget a b                      -- widget to render each item with inside a grid cell
                       -> IO ( Signal Html                -- grid view
                             , Sink (GridCommand a)       -- sink to send events to the grid instance (eg, new items)
                             , Events (GridAction a)      -- events generated by the grid itself (selection etc)
                             , Events b                   -- events generated by grid items
                             , Behavior (Set.Set a)       -- a set of currently selected items
                             )                            -- XXX TODO better API!
gridComponent mbOpts as itemW = do
  (itemSink, itemEvents)            <- newSyncEventOf (undefined                     :: b)
  (actionsSink, actionsEvents)      <- newSyncEventOf (undefined                     :: (GridAction a))
  (lifecycleSink, lifecycleEvents)  <- newSyncEventOf (undefined                     :: (GridCommand a))

  let selE                          = fmap commandToSelection actionsEvents -- :: Events (Set.Set a -> Set.Set a)
  selectedS                         <- accumS (fromMaybe Set.empty $ initialSelection mbOpts) selE
  let selectedB                     = current selectedS

  subscribeEvent (FRP.filter filterResetSelectionEvents lifecycleEvents) $ const . actionsSink $ SelectNone

  asS                               <- stepperS as (fmap (\(Replace as) -> as) (FRP.filter filterReplaceEvents lifecycleEvents))

  let asAndSelS                     = liftA2 (,) asS selectedS                 --  :: Signal ([a], Set.Set a)

  let view                          = fmap (gridW (fromMaybe defaultGridOptions mbOpts) (itemW itemSink) actionsSink) asAndSelS

  return (view, lifecycleSink, actionsEvents, itemEvents, selectedB)

  where
    filterResetSelectionEvents ClearSelection = True
    filterResetSelectionEvents (Replace _)    = True
    filterResetSelectionEvents _              = False

    filterReplaceEvents (Replace _)           = True
    filterReplaceEvents _                     = False

    commandToSelection :: Ord a => GridAction a -> Set.Set a -> Set.Set a
    commandToSelection (Select y') x = let y = Set.fromList y' in
                                       if Set.null (Set.intersection x y)
                                         then Set.union x y
                                         else Set.union (Set.difference x y) (Set.difference y x)
    commandToSelection SelectNone  _ = Set.empty
    commandToSelection _           x = x
