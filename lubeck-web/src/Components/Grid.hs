{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE ScopedTypeVariables        #-}


module Components.Grid
  ( gridComponent
  , GridCommand(..)
  , GridAction(..)
  , GridOptions(..)
  , defaultGridOptions
  ) where

import           Prelude                        hiding (div)
import qualified Prelude

import           Control.Applicative
import           Control.Monad                  (join)
import qualified Data.Set as Set
import           Data.Maybe
import           Data.Monoid

import qualified Web.VirtualDom.Html            as E
import qualified Web.VirtualDom.Html.Attributes as A
import qualified Web.VirtualDom.Html.Events     as Ev

import           Lubeck.App                     (Html)
import           Lubeck.Forms
import           Lubeck.FRP
import qualified Lubeck.FRP                     as FRP
import           Lubeck.Util

-- import           BD.Types
import           BDPlatform.HTMLCombinators


data GridAction a = Select [a] | Delete [a] | Other [a] | SelectNone | Noop deriving Show

-- Maybe make all GridCommands return ([a], Set a) and in 'modifySelection'
-- function, check to see that the Set a is a subset of (Set.fromList [a])
data GridCommand a = Replace [a] | ReplaceSelection (Set.Set a) | ClearSelection

data GridOptions a = GridOptions { deleteButton     :: Bool
                                 , selectButton     :: Bool
                                 , otherButton      :: Bool
                                 , initialSelection :: Set.Set a 
                                 , width            :: Int -- px
                                 , height           :: Int }

defaultGridOptions = GridOptions True True True Set.empty 200 200

gridW :: Ord a => GridOptions a -> (a -> Html) -> Widget ([a], Set.Set a) (GridAction a)
gridW _    _     _        ([], _)              = contentPanel mempty
gridW opts itemW gridSink (items, selectedSet) = contentPanel $ E.div []
  [ E.div [A.class_ "grid-container"] (map (itemWrapperW opts itemW selectedSet gridSink) items) ]

itemWrapperW :: Ord a => GridOptions a -> (a -> Html) -> Set.Set a -> Widget a (GridAction a)
itemWrapperW opts itemW selectedSet gridSink x =
  let selIcon = if Set.member x selectedSet then "check-square" else "check-square-o"
      selCls  = if Set.member x selectedSet then "grid-cell-selected" else ""

  in E.div [ A.class_ ("grid-item-wrapper " <> selCls), A.style $ "width: " <> showJS (width opts) <> "px; height: " <> showJS (height opts) <> "px;"]
        ([buttonIcon_ "btn-link grid-item-delete" "" "trash"    False [Ev.click $ \_ -> gridSink $ Delete [x]] | deleteButton opts]
      <> [buttonIcon_ "btn-link grid-item-select" "" selIcon    False [Ev.click $ \_ -> gridSink $ Select [x]] | selectButton opts]
      <> [buttonIcon_ "btn-link grid-item-other"  "" "circle-o" False [Ev.click $ \_ -> gridSink $ Other  [x]] | otherButton opts]
      <> [itemW x])

gridComponent :: Ord a => Maybe (GridOptions a)           -- custom grid options
                       -> [a]                             -- initial items
                       -> Widget a b                      -- widget to render each item with inside a grid cell
                       -> IO ( Signal Html                -- grid view
                             , Sink (GridCommand a)       -- sink to send events to the grid instance (eg, new items)
                             , Events (GridAction a)      -- events generated by the grid itself (selection etc)
                             , Events b                   -- events generated by grid items
                             , Behavior (Set.Set a)       -- a set of currently selected items
                             )                            -- XXX TODO better API!
gridComponent mbOpts as itemW = do
  (itemSink, itemEvents)            <- newSyncEventOf (undefined                     :: b)
  (actionsSink, actionsEvents)      <- newSyncEventOf (undefined                     :: (GridAction a))
  (lifecycleSink, lifecycleEvents)  <- newSyncEventOf (undefined                     :: (GridCommand a))

  itemsS                            <- stepperS as (fmap (\(Replace as) -> as) (FRP.filter filterResetSelectionEvents lifecycleEvents))
  let selE                          = fmap commandToSelection actionsEvents -- :: Events (Set.Set a -> Set.Set a)
  commandE                          <- reactimateIOAsync $ modifySelection itemsS <$> lifecycleEvents
  selectedS                         <- accumS (maybe Set.empty initialSelection mbOpts) $ merge selE (fmap const commandE) 

  subscribeEvent (FRP.filter filterResetSelectionEvents lifecycleEvents) $ const . actionsSink $ SelectNone

  let selectedB                     = current selectedS
      itemsAndSelectedS             = liftA2 (,) itemsS selectedS                 --  :: Signal ([a], Set.Set a)
      gridView                      = fmap (gridW (fromMaybe defaultGridOptions mbOpts) (itemW itemSink) actionsSink) itemsAndSelectedS 

  return (gridView, lifecycleSink, actionsEvents, itemEvents, selectedB)

  where
    filterResetSelectionEvents ClearSelection       = True
    filterResetSelectionEvents (Replace _)          = True
    filterResetSelectionEvents (ReplaceSelection _) = False

    modifySelection :: Ord a => Signal [a] -> GridCommand a -> FRP (Set.Set a)
    modifySelection items (ReplaceSelection set) = do
      currentItems <- pollBehavior $ current items 
      return $ Set.intersection set (Set.fromList currentItems)
    modifySelection _     (Replace xs)           = return Set.empty
    modifySelection _     (ClearSelection)       = return Set.empty

    commandToSelection :: Ord a => GridAction a -> Set.Set a -> Set.Set a
    commandToSelection (Select y') x = let y = Set.fromList y' in
                                       if Set.null (Set.intersection x y)
                                         then Set.union x y
                                         else Set.union (Set.difference x y) (Set.difference y x)
    commandToSelection SelectNone  _ = Set.empty
    commandToSelection _           x = x
