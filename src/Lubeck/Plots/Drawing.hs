
{-# LANGUAGE GeneralizedNewtypeDeriving, OverloadedStrings, QuasiQuotes, TemplateHaskell, OverloadedStrings, TupleSections #-}
{-# LANGUAGE TemplateHaskell #-}

-- |
-- Basics for drawing plots.
--
-- These are all low-level drawing functions.
--
-- Conventions:
--
--  * All data is normalized to fall inside the /unit hypercube/, meaning that each point in the data
--    set can be expressed as a linear combination of scalars in the range @[0..1]@.
--
--  * The position of each data points is mapped from the hypercube into the plotting rectangle
--    (currently hardcoded as @[(0,0)..(300,300])@).
--
--  * Returns data in the 'Styled' monad. Basic idea is that exctracting values from 'Styled'
--    may affect display (sometimes dramatically), but never the basic semantics of the data.
--
--  Consequently:
--
--  * Data must be normalized and labels, and the labels normalized in the same withOpacity
--    as the data before using this module.
--
--  * Plots generated by this module can be overlayd using the 'Drawing' monoid instance.
--
-- $normalizeInputScalar
-- Input should be normalized so that for each point @x@ in input, x ∈ [0,1].
--
-- $normalizeInputPoint
-- Input should be normalized so that for each point @Point x y@ in input, x ∈ [0,1], y ∈ [0,1].
module Lubeck.Plots.Drawing
    (
    -- * Drawing data
    --   $normalizeInputPoint
    --   $normalizeInputScalar
      scatterData
    , scatterDataX
    , scatterDataY
    , lineData
    , linearData
    , barData
    -- ** Drawing ticks and axis
    , ticks
    , ticksNoFilter
    , labeledAxis
    -- ** Utilities
    , crossLineX
    , crossLineY

    -- * Styling
    , Styling
    , defStyling
    -- TODO all lenses here
    , Styled
    , getStyled
    , withDefaultStyle

    ) where

import Prelude hiding (div)
import qualified Prelude

import qualified Data.JSString
import GHCJS.Types(JSString, jsval)

import Data.Colour (withOpacity)
import qualified Data.Colour.Names as Colors
import Data.Monoid ((<>))
import Control.Applicative
import Data.VectorSpace
import Data.AffineSpace

import Control.Monad.Reader

import Control.Lens ()
import Control.Lens.TH (makeLenses)

-- import qualified Web.VirtualDom as VD
-- import qualified Web.VirtualDom.Html as H
-- import qualified Web.VirtualDom.Html.Attributes as H
-- import qualified Web.VirtualDom.Html.Events as H
-- import qualified Web.VirtualDom.Svg.Events as SvgEv

-- import Lubeck.FRP
-- import Lubeck.Forms
-- import Lubeck.Forms.Basic
import Lubeck.Drawing
import Lubeck.Util(showJS)
import qualified Lubeck.Drawing

data Styling = Styling
  { _dummy :: ()
  -- Rendering rectangle (default (300x300))


  -- Line plots
    -- stroke color, stroke width (absolute)
  -- Scatter plots
    -- point size, fillColor, strokeColor, shape?

  -- Bar plots
    --


  }
  deriving (Read, Show)

defStyling = Styling
  { _dummy = ()

  }
makeLenses ''Styling

newtype Styled a = Styled { _getStyled :: Reader Styling a }
  deriving (Functor, Applicative, Monad, MonadReader Styling)

instance Monoid a => Monoid (Styled a) where
  mempty = pure mempty
  mappend = liftA2 mappend

getStyled :: Styled a -> Styling -> a
getStyled = runReader . _getStyled

withDefaultStyle :: Styled a -> a
withDefaultStyle x = getStyled x defStyling

-- Line overlays, box plots, heat maps
-- Stacking and graphing box plots
-- Generating legends
-- Generating (proper axises)
-- Visualize pairs, lists, ordered sets, maps, trees, directed graphs
-- Overlay lines (i.e. for interaction browser)

-- We will require basic envelopes
-- Optimally, also textual envelopes


-- Pie charts
-- See https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Clipping_and_masking

-- | Draw data for a scatter plot.
scatterData :: [R2] -> Styled Drawing
scatterData ps = return $ scale 300 $ mconcat $ fmap (\p -> translate (p .-. origin) base) ps
  where
    base = fillColorA (Colors.red `withOpacity` 0.6) $ scale (10/300) circle
    origin = Point 0 0

-- | Draw data for a scatter plot ignoring Y values.
scatterDataX :: [R2] -> Styled Drawing
scatterDataX ps = return $ scale 300 $ mconcat $ fmap (\p -> translateX (x p) base) ps
  where
    base = strokeColorA (Colors.red `withOpacity` 0.6) $ strokeWidth 1.5 $ translateY 0.5 $ verticalLine
    origin = Point 0 0

-- | Draw data for a scatter plot ignoring X values.
scatterDataY :: [R2] -> Styled Drawing
scatterDataY ps = return $ scale 300 $ mconcat $ fmap (\p -> translateY (y p) base) ps
  where
    base = strokeColorA (Colors.red `withOpacity` 0.6) $ strokeWidth 1.5 $ translateX 0.5 $ horizontalLine
    origin = Point 0 0

-- | Draw data for a line plot.
lineData :: [R2] -> Styled Drawing
lineData []     = mempty
lineData [_]    = mempty
lineData (p:ps) = return $ scale 300 $ translate (p .-. origin) $ lineStyle $ segments $ betweenPoints $ (p:ps)
  where
    lineStyle = strokeColorA (Colors.red `withOpacity` 0.6) . fillColorA (Colors.black `withOpacity` 0) . strokeWidth 2.5
    origin = Point 0 0

-- | Draw a box plot.
barData :: [R] -> Styled Drawing
barData ps = return $ scale 300 $ mconcat $
    fmap (\p -> scaleX (1/fromIntegral (length ps)) $ scaleY p $ base) ps
  where
    -- TODO horizontal stacking (nicer with proper envelopes!)
    base = fillColorA (Colors.blue `withOpacity` 0.6) $ square

-- | Draw a linear function @ax + b@. Renders the function in the [0..1] domain,
--   i.e to get a line intersecting the outer ends of the X and Y axis use @linearData (-1) 1@.
linearData :: R -> R -> Styled Drawing
linearData a b = lineData $ fmap (\x -> x `Point` f x) [0,1]
  where
    f x = a*x + b







-- | Draw ticks.
-- Each argument is a list of tick positions (normalized to [0,1]) and an optional tick label.
-- Positions outside the normalized range are discarded.
ticks
  :: [(Double, JSString)] -- ^ X axis ticks.
  -> [(Double, JSString)] -- ^ Y axis ticks.
  -> Styled Drawing
ticks xt yt = ticksNoFilter (filterTicks xt) (filterTicks yt)
  where
    filterTicks = filter (withinNormRange . fst)
    withinNormRange x = 0 <= x && x <= 1

-- | Draw ticks.
-- Each argument is a list of tick positions (normalized to [0,1]) and an optional tick label.
-- Contrary to 'ticks', 'ticksNoFilter' accept ticks at arbitrary positions.
ticksNoFilter
  :: [(Double, JSString)] -- ^ X axis ticks.
  -> [(Double, JSString)] -- ^ Y axis ticks.
  -> Styled Drawing
ticksNoFilter xt yt = return $ mconcat [xTicks, yTicks]
  where
    xTicks = mconcat $ flip fmap xt $
      \(pos,str) -> translateX (pos * 300) $
        (scale kBasicTickLength $ strokeColor Colors.black $ strokeWidth 1.5 $ translateY (-0.5) verticalLine) <> (translateY (kBasicTickLength * (-1.5)) .rotate (turn*1/8)) (textEnd str)
    yTicks = mconcat $ flip fmap yt $
      \(pos,str) -> translateY (pos * 300) $
        (scale kBasicTickLength $ strokeColor Colors.black $ strokeWidth 1.5 $ translateX (-0.5) horizontalLine) <> (translateX (kBasicTickLength * (-1.5)) .rotate (turn*0.00001/8)) (textEnd str)

    kBasicTickLength = 10
    -- Note: Add infinitesimal slant to non-slanted text to get same anti-aliasing behavior
    -- kPositionTickRelAxis = (-0.5) -- (-0.5) for outside axis, 0 for centered around axis, 0.5 for inside
    -- kPositionLabelRelAxis = (-0.8) -- (kPositionTickRelAxis-0) to make label touch tick, (kPositionTickRelAxis-1) to offset by length of tick

-- | Draw X and Y axis.
labeledAxis
  :: JSString -- ^ X axis label.
  -> JSString -- ^ Y axis label.
  -> Styled Drawing
labeledAxis labelX labelY = return $ mconcat
  [ scale 300 $ axis
  , translateY (300/2) $ translateX (-20) $ rotate (turn/4) $ textMiddle labelY
  , translateX (300/2) $ translateY (-20) $ textMiddle labelX]

axis = mconcat [axisY, axisX]
axisX = strokeWidth 1.5 $ strokeColor Colors.black $ translateX 0.5 horizontalLine
axisY = strokeWidth 1.5 $ strokeColor Colors.black $ translateY 0.5 verticalLine

crossLineX n = translateX (n * 300) $ strokeWidth 2 $ strokeColor Colors.lightblue $ axisY
crossLineY n = translateY (n * 300) $ strokeWidth 2 $ strokeColor Colors.lightblue $ axisX











-- Interactive
--
-- -- | Draw data for a scatter plot with an optional drawing pop-up.
-- scatterData :: [(R2, Maybe Drawing)] -> IO (Signal Drawing)
-- scatterData ps = scale 300 $ mconcat $ fmap (\p -> translate (p .-. origin) base) ps
--   where
--     base = fillColorA (Colors.red `withOpacity` 0.6) $ scale (10/300) circle
--     origin = R2 0 0
